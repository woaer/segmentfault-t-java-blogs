{
  "watchNum": "54039",
  "blogs": [
    {
      "id": "1190000019422971",
      "title": "易用的 canal  java 客户端 canal-client",
      "url": "/a/1190000019422971",
      "desc": "canal 自身提供了简单的客户端，数据格式较为复杂，处理消费数据也不太方便，为了方便给业务使用，提供一种直接能获取实体对象的方式来进行消费才更方便。先说一下实现的思路，首先canal 客户端的消息对象有两种...",
      "author": {
        "nick": "yangpeng",
        "homepage": "/u/yangpeng_5c9844d43d177"
      }
    },
    {
      "id": "1190000019421803",
      "title": "一次和前端的相互甩锅的问题记录",
      "url": "/a/1190000019421803",
      "desc": "我们在APP上有个功能，需要获取用户当前定位，然后当用户关闭了GPS后，没有获取到用户定位，会触发一个bug,弹窗内容如下。",
      "author": {
        "nick": "方丈的寺院",
        "homepage": "/u/fangzhangdesiyuan"
      }
    },
    {
      "id": "1190000019421263",
      "title": "Java学习笔记",
      "url": "/a/1190000019421263",
      "desc": "1、读输入 {代码...} 2、数组 {代码...} {代码...} {代码...} 3、包裹类型 {代码...} 可以通过包裹类型获取该类型的最大最小值，判断是否是字母什么的 可以有更多的功能扩展 4、Math类 {代码...} 5、字符串 {代码...",
      "author": {
        "nick": "Pickpikaa",
        "homepage": "/u/pickpikaa"
      }
    },
    {
      "id": "1190000019420778",
      "title": "dubbo源码解析（四十七）服务端处理请求过程",
      "url": "/a/1190000019420778",
      "desc": "上一篇讲到了消费端发送请求的过程，该篇就要将服务端处理请求的过程。也就是当服务端收到请求数据包后的一系列处理以及如何返回最终结果。我们也知道消费端在发送请求的时候已经做了编码，所以我们也需要在服务...",
      "author": {
        "nick": "crazyhzm",
        "homepage": "/u/mmmmm_592a5e72c8ea7"
      }
    },
    {
      "id": "1190000019420288",
      "title": "1.3-知识图谱怎么去做？",
      "url": "/a/1190000019420288",
      "desc": "知识图谱怎么去做，这当然不是几句话说得清楚的。首先肯定要先基于自身的业务进行思考，这里整理一些知识图谱构建的主要路径。",
      "author": {
        "nick": "小磊哥er",
        "homepage": "/u/yzsunlei"
      }
    },
    {
      "id": "1190000019420279",
      "title": "1.2-知识图谱有什么用？",
      "url": "/a/1190000019420279",
      "desc": "最典型的就是在谷歌搜索引擎里面应用。谷歌是在2012年率先提出来知识图谱的概念，提出这个概念的最主要的目的就是用于改善它的搜索引擎的体验。",
      "author": {
        "nick": "小磊哥er",
        "homepage": "/u/yzsunlei"
      }
    },
    {
      "id": "1190000019420268",
      "title": "1.1-知识图谱是什么？",
      "url": "/a/1190000019420268",
      "desc": "知识图谱自上世纪60年代从语义网络发展起来以后，分别经历了1980年代的专家系统、1990年代的贝叶斯网络、2000年代的OWL和语义WEB，以及2010年以后的谷歌的知识图谱。",
      "author": {
        "nick": "小磊哥er",
        "homepage": "/u/yzsunlei"
      }
    },
    {
      "id": "1190000019419783",
      "title": "MySQL索引深入理解底层数据结构",
      "url": "/a/1190000019419783",
      "desc": "如果每次的数据都是以1,2,3,4,5,6的形式添加，会造成二叉树单边增长，从而导致查询效率依然低下红黑树会自己旋转，会有一个自平衡的过程，但是高度是不可控的,（height）,如果是百万级别的数据，高度是完全不可控的",
      "author": {
        "nick": "SkinnyTracy",
        "homepage": "/u/skinnytracy"
      }
    },
    {
      "id": "1190000019418456",
      "title": "开源项目几点心得，Java架构必会几大技术点",
      "url": "/a/1190000019418456",
      "desc": "Java架构必会几大技术点 关于学习架构，必须会的几点技术 列表项目 java反射技术 xml文件处理 properties属性文件处理 线程安全机制 annocation注解 设计模式 代理机制（aop） serlvet基础(过滤器等等) 几样比较...",
      "author": {
        "nick": "scott",
        "homepage": "/u/jeecg"
      }
    },
    {
      "id": "1190000019418273",
      "title": "设计模式之单例模式",
      "url": "/a/1190000019418273",
      "desc": "0x01.定义与类型 定义：保证一个类仅有一个实例，并提供一个全局访问点 类型：创建型 UML 单例模式的基本要素 私有的构造方法 指向自己实例的私有静态引用 以自己实例为返回值的静态的公有的方法 0x02.适用场景 ...",
      "author": {
        "nick": "猿在天",
        "homepage": "/u/cos2a"
      }
    },
    {
      "id": "1190000019417975",
      "title": "乐字节-Java8核心特性实战之Stream（流）",
      "url": "/a/1190000019417975",
      "desc": "大家好，我是乐字节的小乐。说起流，我们会联想到手机、电脑组装流水线,物流仓库商品包装流水线等等,如果把手机 ,电脑,包裹看做最终结果的话,那么加工商品前的各种零部件就可以看做数据源，而中间一系列的加工作...",
      "author": {
        "nick": "乐字节",
        "homepage": "/u/lezijie"
      }
    },
    {
      "id": "1190000019417750",
      "title": "JAVA前后端分离开发环境搭建详细教程——JeecgBoot快速开发平台",
      "url": "/a/1190000019417750",
      "desc": "目录索引： 后端开发工具 前端开发工具 Nodejs镜像 WebStorm入门配置 {代码...} 后端开发工具 序号 工具 参考 1 eclipse安装lombok插件 [链接] 2 Eclipse自定义皮肤主题 [链接] 3 Eclipse常用快捷键 [链接] 前端...",
      "author": {
        "nick": "scott",
        "homepage": "/u/jeecg"
      }
    },
    {
      "id": "1190000019417697",
      "title": "Jeecg-Boot 极简部署方案",
      "url": "/a/1190000019417697",
      "desc": "基于 spring boot 特性 1、首先修改配置，去掉项目名 jeecg-boot {代码...} 2、修改路由History 模式为“hash” {代码...} 然后 ant-design-jeecg-vue 运行 build {代码...} 3、然后将编译之后dist下的文件复制到 j...",
      "author": {
        "nick": "scott",
        "homepage": "/u/jeecg"
      }
    },
    {
      "id": "1190000019417591",
      "title": "什么是Java内部类？",
      "url": "/a/1190000019417591",
      "desc": "内部类 (一) 概述 把类定义在另一个类的内部，该类就被称为内部类。 举例：把类Inner定义在类Outer中，类Inner就被称为内部类。 {代码...} (二) 内部类的访问规则 ​ A:可以直接访问外部类的成员，包括私有 ​ B:外...",
      "author": {
        "nick": "BWH_Steven",
        "homepage": "/u/bwh_steven"
      }
    },
    {
      "id": "1190000019416278",
      "title": "leetcode363. Max Sum of Rectangle No Larger Than K",
      "url": "/a/1190000019416278",
      "desc": "现有一个由整数构成的矩阵，问从中找到一个子矩阵，要求该子矩阵中各个元素的和为不超过k的最大值，问子矩阵中元素的和为多少?注：后面的文章中将使用[左上角顶点坐标，右下角顶点坐标]来表示一个矩阵，如[(1,2),...",
      "author": {
        "nick": "raledong",
        "homepage": "/u/raledong"
      }
    }
  ]
}